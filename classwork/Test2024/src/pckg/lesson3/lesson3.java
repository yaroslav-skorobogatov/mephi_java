package pckg.lesson3;

import java.util.Arrays;

public class lesson3 {
    public static void main(String[] args) {


    }

}

//cmd + o поиск класса по названи

/*
//Отношение между объектами
//Ассоциация
//Агрегация и композиция являются частными случаями ассоциации

//Агрегация представляет собой "слабую" форму связи между объектами.
// Она описывает отношения типа "имеет", где один объект может содержать другой объект, но оба объекта могут существовать независимо друг от друга.

//Пример агрегации:
class Engine {
    // Двигатель может существовать сам по себе
}

class Car {
    Engine engine;  // Двигатель может быть передан машине

    Car(Engine engine) {
        this.engine = engine;
    }
}

//Композиция — ещё более «жёсткое» отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежать ещё кому-то.
//Пример композиции:
class Chapter {
    // Глава является неотъемлемой частью книги
}

class Book {
    Chapter chapter;  // Глава существует только в составе книги

    Book() {
        chapter = new Chapter();  // Книга создаёт главу
    }
}


    //принципы SOLID
    //чтобы код был расширяемый и поддерживаемым
    // Принципы SOLID:

    // 1. Single Responsibility Principle (SRP):
    //    Принцип единственной ответственности: Класс должен иметь только одну причину для изменения, фокусируясь на одной ответственности.
    //
    // 2. Open/Closed Principle (OCP):
    //    Принцип открытости/закрытости: Классы должны быть открыты для расширения, но закрыты для модификации.
    //
    // 3. Liskov Substitution Principle (LSP):
    //    Принцип подстановки Барбары Лисков: Подтипы должны быть взаимозаменяемыми с их базовыми типами без изменения корректности.
    //
    // 4. Interface Segregation Principle (ISP):
    //    Принцип разделения интерфейса: Клиенты не должны зависеть от интерфейсов, которые они не используют.
    //
    // 5. Dependency Inversion Principle (DIP):
    //    Принцип инверсии зависимостей: Модули верхнего уровня должны зависеть от абстракций, а не от модулей нижнего уровня.


            //  Статическое и динамическое связывания
            //      Статическое:
            //      - во время компиляции
            //      - пример – перегрузка (тот же метод, но для других входящих параметров, тоесть получается уже несколько вариантов одного метода)
            //      - private/static/final
            //
            //  Динамическое:
            //      - во время выполнения
            //      - пример – переопределение (тот же метод, в котором изменили логику)
            //      - наследование

 */